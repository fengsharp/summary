# 1. 对象关系
## 1.1 纵向关系
继承
## 1.2 横向关系(相关性)
1. 关联  
    如客户和订单，是一个固定的关系，订单可以作为客户的成员  
2. 聚合  
    整体到局部，不负责成员的生命周期，指针表示，如大雁和雁群  
3. 组合  
    整体和局部，切负责成员的生命周期，对象表示，如人和大脑  
4. 依赖  
    作为参数，局部变量，或者竟态方式访问  

只有组合的方式，创建和销毁都在类内部处理，其他的都是使用了其信息，并不维护其生命周期的  

# 2. 值语义与对象语义
值语义是指：拷贝后的对象和原来对象无关，拷贝构造的对象和原对象不在共享内存（纠缠在一起），比如std::string，如果用默认的拷贝构造函数，则新旧两个对象相互共享了内存，就不是值语义对象了，实现了拷贝构造，赋值，析构方法后，新旧两个对象的内存隔离，就是值语义，方便生命周期的管理。  

对象语义指：类似java，一旦一个对象创建成功，则该对象就是独一份，其他地方只能通过指针来引用该对象，且有引用的地方不能被jvm回收，直到引用都结束，才会释放内存空间，而C++可以通过智能指针的方式达到类似的对象语义对象，首先禁止掉拷贝、赋值，对象创建后，无论是以栈对象，还是以堆对象（最好智能指针方式管理）存在，都以地址方式进行访问，不会出现新旧两个对象共享成员变量指向的同一内存空间现象。  

而不同于java，对象语义在C++中还有一种方式，即内部指针通过智能指针方式管理，这样拷贝的对象和原有对象共享空间，一个修改，另一个也会修改，且释放资源不会出问题。相当于值语义对象，内部有一个对象语义的对象，通过智能指针将对象语义的成员变量，转为了值语义对象，从而保证了整体还是值对象。

1. 默认的class是值语义，默认构造函数、拷贝构造、赋值都是值语义的，即新生成对象和原有的对象没有任何关系，值语义的对象，维护内部成员的生死周期。需要实现拷贝构造、赋值运算符、析构，保证新生成对象和原有对象成员变量不在共享同样的内存。
2. 对象语义的实现有两种方式，一种是基于对象的方式，delete拷贝、赋值，作为一个独一无二的object存在，另一种方式是，采用智能指针共享成员变量指向内存的所有权，保证一个对象的内部修改，完全反映到另一个对象身上，且轻松管理生命周期，不会出现一个obj是否了内存，另一个也要释放同样的内存的情况。

值语义编程：仅仅用了值语义对象  
面向对象编程：用了对象语义  

# 3. 面向过程与面向对象
oop = o + o + msg  
o = 算法+数据结构  
考虑问题其实应该以输入数据和输出的数据为重点，此处的数据应该表示为object，即以object为中心，去思考不同的对象如何模拟了动态的过程，从每个对象的数据信息出发思考紧耦合和职责划分的问题  
思考需求（问题），明确需求（问题）输入是什么，输出是什么，需要什么样的一个过程，输入和输出确定角色和系统边界，过程分析动态的业务流程，细化内部对象  
class最重要的是封装了数据，让大脑能够以紧凑数据信息的抽象方式来简化复杂的问题，紧凑数据的抽象，除了静态（成员），还抽象了数据本身状态的转换（方法），如此可以站在更高一层次来思考问题，或者从上到下的方式思路，以TDD的方式进行开发。

# 4. 如何分析出class？
1. 按照需求分析出流程，每个流程代表了一个职责，比如用户登录
    用户(client) - 输入(username, password) 边界端 - 接收请求 - 查询数据库用户记录(username, password) - 判断登录成功失败 - 返回请求
2. 将流程（职责）归类
    - controller api(接收请求，返回请求) - 对外接口，接收数据和返回数据
    - service(判断登录成功失败)
    - dao 查询数据库用户记录(db操作)
3. 找出对象关系
    - UserControl -> UserService 组合
    - UserService -> UserDao     组合
    - UserBean   UserControl UserService UserDao 都依赖，对象间消息传递实体对象
4. 按照流程职责，分析出对应的行为方法
    - UserControl:login
    - UserService:login
    - UserDao:findUser





